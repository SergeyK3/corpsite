# FILE: docs/adr/ADR-020-regular-tasks-contract-v1.md

# ADR-020: Regular Tasks (журнал регулярных задач) — контракт v1

## Статус
Принято (Draft → Implement)

## Контекст
В текущей модели постановка задач зависит от человека (директор/зам/руководитель может забыть создать задачу). Требуется механизм неизбежного появления задач по календарному расписанию: при наступлении начала недели/месяца (и других периодов) система автоматически генерирует задачи исполнителям из “журнала регулярных задач”.

Также требуется:
- строгая идемпотентность (никаких дублей при повторных запусках);
- прозрачный журнал запусков/созданий;
- совместимость с текущей моделью `tasks` и FSM;
- инициатор автосозданных задач — системная учетная запись (поддержка/системный пользователь), что пользователя устраивает.

## Решение
Вводится сущность **regular_tasks** как источник истины (шаблоны). На ее основе генератор (cron/worker) создает экземпляры задач в `tasks` для конкретного периода (неделя/месяц и т.д.). Генерация идемпотентна через уникальный ключ (dedupe) на уровне БД.

### Термины
- **Regular Task** — шаблон регулярной задачи (запись в журнале).
- **Task Instance** — конкретная задача в `tasks`, созданная в рамках периода, возможно с FK на `regular_tasks`.
- **Period** — календарный период (week/month/quarter/year), представленный как `period_id` (существующая или расширяемая модель).

## Область применения
- Периодичность v1: **weekly** и **monthly** (основные), опционально daily/quarterly/yearly — как расширение без ломки контракта.
- Назначение исполнителя: по **executor_role_id** (как сейчас), `assignment_scope` — как в `tasks`.

## Контракт данных v1

### 1) Таблица `regular_tasks` (шаблоны)
Минимальный набор полей (v1):

- `regular_task_id` (PK, bigint, identity)
- `is_active` (bool, default true)
- `title` (text, not null)
- `description` (text, null)
- `executor_role_id` (bigint, not null)
- `assignment_scope` (assignment_scope_t, not null) — совместимо с `tasks.assignment_scope`
- `schedule_type` (text, not null) — значения: `weekly|monthly` (v1)
- `schedule_params` (jsonb, not null) — параметры расписания
- `create_offset_days` (int, not null, default 0) — за сколько дней до “точки” периода создавать задачу
- `due_offset_days` (int, not null, default 0) — срок “+N дней” от даты создания или от “точки” периода (см. ниже)
- `created_by_user_id` (bigint, null) — кто завел шаблон (не инициатор инстанса)
- `created_at` (timestamptz, default now())
- `updated_at` (timestamptz, default now())

Рекомендации по `schedule_params` (v1):
- weekly: `{ "byweekday": [1], "time": "10:00" }`  
  где `byweekday`: 1..7 (Пн..Вс), `time` — локальное время (UTC+5 по проекту)
- monthly: `{ "bymonthday": [1], "time": "10:00" }`  
  `bymonthday`: 1..31 или -1 (последний день месяца)

Примечание: `time` и timezone в v1 фиксируем на уровне приложения (UTC+5). Поле `timezone` можно добавить позже без ломки.

### 2) Связь с `tasks`
В `tasks` уже есть `regular_task_id`. Считается обязательной связью для автосозданных задач и nullable для ручных.

Дополнительно вводится/закрепляется дедупликация на уровне БД:
- уникальность для автогенерации:  
  **UNIQUE (`regular_task_id`, `period_id`, `executor_role_id`)**

Это обеспечивает идемпотентность даже при повторном запуске генератора.

### 3) Периоды (`periods`)
Для weekly/monthly должна существовать возможность получить/создать `period_id` для:
- недели (например ISO week)  
- месяца (YYYY-MM)

Если текущая таблица периодов пока “месячная”, допускается расширить ее типом периода:
- `period_type`: `week|month` (v1)
- `period_key`: текстовый ключ (`2026-W05`, `2026-01`)
Либо завести отдельную таблицу для weekly periods. Деталь реализации не фиксируется в этом ADR, важен контракт: **генератор должен однозначно вычислять `period_id` по дате и типу расписания**.

## Генератор регулярных задач (policy v1)

### Инициатор автосозданных задач
- `initiator_user_id` для сгенерированных задач = **SYSTEM** (системная учетная запись/поддержка).
- В `task_audit_log.meta` или в payload события можно писать:
  - `generated_from_regular_task_id`
  - `schedule_type`
  - `period_key`

### Алгоритм генерации (идемпотентный)
На каждый запуск генератор:
1) определяет “сегодня” в локальном времени проекта (UTC+5);
2) выбирает активные `regular_tasks`;
3) для каждой записи вычисляет “точку” расписания (неделя/месяц) и соответствующий `period_id`;
4) принимает решение “создавать сейчас?” с учетом `create_offset_days`;
5) выполняет upsert в `tasks`:
   - INSERT с `regular_task_id`, `period_id`, `title`, `description`, `executor_role_id`, `assignment_scope`, `status=IN_PROGRESS` (или другой policy v1)
   - ON CONFLICT по уникальному ключу — DO NOTHING
6) пишет запись в журнал генератора (см. ниже).

### Сроки (due) v1
Если в `tasks` нет поля due_date, то в v1 срок может:
- не фиксироваться явно (только в тексте/описании),
- либо добавляться позже отдельным полем без ломки модели.
Если поле срока появится, использовать `due_offset_days`.

## Журнал генерации (observability v1)
Вводится таблица `regular_task_runs` (или аналог) — журнал запусков генератора:

- `run_id` (PK)
- `started_at`, `finished_at`
- `status` (`ok|partial|failed`)
- `stats` (jsonb): `{ "templates_total": X, "created": Y, "deduped": Z, "errors": N }`
- `errors` (jsonb, nullable): список ошибок по regular_task_id/period

Это обеспечивает прозрачность для поддержки.

## API / UI (контракт v1)
UI “Регулярные задачи”:
- список шаблонов (`GET /regular-tasks`)
- создать/изменить/вкл-выкл (`POST/PUT/PATCH`)
- “сгенерировать сейчас” для теста (`POST /regular-tasks/{id}/generate-now`) — опционально
- журнал запусков генератора (`GET /regular-tasks/runs`)

Backend-интерфейс генератора:
- внутренний endpoint для cron/worker: `POST /internal/regular-tasks/run`
  - возвращает stats по созданию/дедупликации

## Решения по событиям
В v1 события `task_event_type` в БД: `REPORT_SUBMITTED`, `APPROVED`, `REJECTED`.
Статус `ARCHIVED` как событие **пока не добавляется** в enum; вернемся к этому при внедрении poller/доставки событий. Архивирование остается статусом и audit-записью.

## Последствия
Плюсы:
- задачи появляются автоматически и предсказуемо;
- нет дублей при повторных запусках;
- есть прозрачный журнал генерации;
- минимальная инвазия в текущий контур `tasks`/FSM.

Минусы/ограничения:
- назначение по роли означает, что несколько пользователей с одной ролью формально “исполнители” (текущее свойство модели);
- weekly/monthly periods требуют корректной модели `period_id` (расширение таблицы периодов либо отдельная таблица).

## План внедрения (минимальный)
1) Миграция: таблица `regular_tasks` + уникальный индекс в `tasks` (`regular_task_id`, `period_id`, `executor_role_id`).
2) Генератор: сервис `regular_tasks_service` + internal endpoint `/internal/regular-tasks/run`.
3) Журнал: `regular_task_runs`.
4) Один сквозной тест: “наступление периода → созданы задачи → повторный запуск → дублей нет”.
